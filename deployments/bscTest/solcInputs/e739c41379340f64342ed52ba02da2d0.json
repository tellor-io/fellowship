{
  "language": "Solidity",
  "sources": {
    "contracts/Fellowship.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\nimport \"./interfaces/ERC20Interface.sol\";\r\n\r\n/****\r\n\r\n████████╗██╗░░██╗███████╗  ███████╗███████╗██╗░░░░░██╗░░░░░░█████╗░░██╗░░░░░░░██╗░██████╗██╗░░██╗██╗██████╗░\r\n╚══██╔══╝██║░░██║██╔════╝  ██╔════╝██╔════╝██║░░░░░██║░░░░░██╔══██╗░██║░░██╗░░██║██╔════╝██║░░██║██║██╔══██╗\r\n░░░██║░░░███████║█████╗░░  █████╗░░█████╗░░██║░░░░░██║░░░░░██║░░██║░╚██╗████╗██╔╝╚█████╗░███████║██║██████╔╝\r\n░░░██║░░░██╔══██║██╔══╝░░  ██╔══╝░░██╔══╝░░██║░░░░░██║░░░░░██║░░██║░░████╔═████║░░╚═══██╗██╔══██║██║██╔═══╝░\r\n░░░██║░░░██║░░██║███████╗  ██║░░░░░███████╗███████╗███████╗╚█████╔╝░░╚██╔╝░╚██╔╝░██████╔╝██║░░██║██║██║░░░░░\r\n░░░╚═╝░░░╚═╝░░╚═╝╚══════╝  ╚═╝░░░░░╚══════╝╚══════╝╚══════╝░╚════╝░░░░╚═╝░░░╚═╝░░╚═════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░\r\n\r\n*****/\r\n\r\n/** \r\n @author Tellor Inc.\r\n @title Fellowship\r\n @dev This contract holds the selected few chosen as part of the Fellowship\r\n**/\r\ncontract Fellowship {\r\n    //Storage\r\n    enum Status {ACTIVE, INACTIVE, PENDING_WITHDRAW, UNFUNDED}\r\n\r\n    struct Walker {\r\n        Status status; //status of walker\r\n        uint256 date; //date the walker initally was chosen\r\n        uint256 fellowshipIndex; //index of walker in the fellowship array\r\n        uint256 balance; //TRB balance of walker (must be > stakeAmount to be ACTIVE)\r\n        uint256 rewardBalance; //balance of rewards they own\r\n        string name; //name of walker\r\n    }\r\n\r\n    uint256 public lastPayDate; //most recent date walkers were paid\r\n    uint256 public lastPayDate2; //most recent date walkers were paid\r\n    uint256 public rewardPool; //sum of all payments for services in contract\r\n    uint256 public stakeAmount; //minimum amount each walker needs to stake\r\n    address public rivendale; //the address of the voting contract\r\n    address public tellor; //address of tellor (the token for staking and payments)\r\n\r\n    mapping(address => mapping(bytes32 => bytes)) information; //allows parties to store arbitrary information\r\n    mapping(address => Walker) public walkers; //a mapping of an address to their information as a Walker\r\n    mapping(address => uint256) public payments; //a mapping of an address to the payment amount they've given\r\n    //The Fellowship:\r\n    address[] public fellowship; //The array of chosen individuals who are part of the fellowship\r\n\r\n    //Events\r\n    event NewWalker2(address walker);\r\n    event NewWalker(address walker);\r\n    event NewWalkerInformation(address walker, bytes32 input, bytes output);\r\n    event WalkerBanished(address walker);\r\n    event StakeWithdrawalRequestStarted(address walker);\r\n    event StakeWithdrawn(address walker);\r\n    event PaymentDeposited(address payee, uint256 amount);\r\n    event RewardsPaid(uint256 rewardPerWalker);\r\n\r\n    //Modifiers\r\n    /**\r\n     * @dev This modifier restricts the function to only the Rivendale contract\r\n     */\r\n    modifier onlyRivendale {\r\n        require(\r\n            msg.sender == rivendale,\r\n            \"Only rivendale can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    //Functions\r\n    /**\r\n     * @dev Constructor for setting initial variables\r\n     * @param _tellor the address of the tellor contract\r\n     * @param _initialWalkers an array of three addresses to serve as the initial walkers\r\n     */\r\n    constructor(address _tellor, address[3] memory _initialWalkers) {\r\n        tellor = _tellor;\r\n        _newWalker(_initialWalkers[0], \"Aragorn\");\r\n        _newWalker(_initialWalkers[1], \"Legolas\");\r\n        _newWalker(_initialWalkers[2], \"Gimli\");\r\n        stakeAmount = 10 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to banish a walker\r\n     * @param _oldWalker address of walker to be banished (removed from Fellowship)\r\n     **/\r\n    function banishWalker(address _oldWalker) external onlyRivendale {\r\n        _banishWalker(_oldWalker);\r\n        emit WalkerBanished(_oldWalker);\r\n    }\r\n\r\n    function depositPayment(uint256 _amount) external {\r\n        payReward();\r\n\r\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\r\n        payments[msg.sender] += _amount;\r\n        rewardPool += _amount;\r\n        emit PaymentDeposited(msg.sender, _amount);\r\n    }\r\n\r\n    function depositStake(uint256 _amount) external {\r\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\r\n        walkers[msg.sender].balance += _amount;\r\n        require(\r\n            walkers[msg.sender].status != Status.INACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        require(\r\n            walkers[msg.sender].status != Status.PENDING_WITHDRAW,\r\n            \"Walker has wrong status\"\r\n        );\r\n        if (walkers[msg.sender].balance >= stakeAmount) {\r\n            walkers[msg.sender].status = Status.ACTIVE;\r\n        }\r\n    }\r\n\r\n    function newRivendale(address _newRivendale) external {\r\n        require(\r\n            msg.sender == rivendale || rivendale == address(0),\r\n            \"Only rivendale can call this function.\"\r\n        );\r\n        rivendale = _newRivendale;\r\n    }\r\n\r\n    function newWalker(address _walker, string memory _name)\r\n        external\r\n        onlyRivendale\r\n    {\r\n        require(walkers[_walker].date == 0, \"cannot already be a walker\");\r\n        _newWalker(_walker, _name);\r\n    }\r\n\r\n    function payReward() public {\r\n        lastPayDate = block.timestamp;\r\n\r\n        if (rewardPool > 0) {\r\n            uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\r\n            if (timeSinceLastPayment > 6 * 30 days) {\r\n                timeSinceLastPayment = 6 * 30 days;\r\n            }\r\n            uint256 reward =\r\n                (rewardPool * timeSinceLastPayment) /\r\n                    6 /\r\n                    30 days /\r\n                    fellowship.length;\r\n            for (uint256 i = 0; i < fellowship.length; i++) {\r\n                if (walkers[fellowship[i]].status == Status.ACTIVE) {\r\n                    walkers[fellowship[i]].rewardBalance += reward;\r\n                    rewardPool -= reward;\r\n                }\r\n            }\r\n            emit RewardsPaid(reward);\r\n        }\r\n    }\r\n\r\n    //to pay out the reward\r\n    function recieveReward() external {\r\n        require(\r\n            walkers[msg.sender].status == Status.ACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        ERC20Interface(tellor).transfer(\r\n            msg.sender,\r\n            walkers[msg.sender].rewardBalance\r\n        );\r\n        walkers[msg.sender].rewardBalance = 0;\r\n    }\r\n\r\n    function requestStakingWithdraw() external {\r\n        require(\r\n            walkers[msg.sender].status != Status.INACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        walkers[msg.sender].status = Status.PENDING_WITHDRAW;\r\n        walkers[msg.sender].date = block.timestamp;\r\n        emit StakeWithdrawalRequestStarted(msg.sender);\r\n    }\r\n\r\n    function setStakeAmount(uint256 _amount) external onlyRivendale {\r\n        stakeAmount = _amount;\r\n        for (uint256 i = 0; i < fellowship.length; i++) {\r\n            if (walkers[fellowship[i]].balance < stakeAmount) {\r\n                walkers[fellowship[i]].status = Status.UNFUNDED;\r\n            }\r\n        }\r\n    }\r\n\r\n    //a function to store input about keys on other chains or other necessary details;\r\n    function setWalkerInformation(bytes32 _input, bytes memory _output)\r\n        external\r\n    {\r\n        information[msg.sender][_input] = _output;\r\n        emit NewWalkerInformation(msg.sender, _input, _output);\r\n    }\r\n\r\n    function slashWalker(\r\n        address _walker,\r\n        uint256 _amount,\r\n        bool _banish\r\n    ) external onlyRivendale {\r\n        walkers[_walker].balance -= _amount;\r\n        rewardPool += _amount;\r\n        if (_banish) {\r\n            _banishWalker(_walker);\r\n        } else if (walkers[_walker].balance < stakeAmount) {\r\n            walkers[_walker].status = Status.UNFUNDED;\r\n        }\r\n    }\r\n\r\n    function withdrawStake() external {\r\n        require(\r\n            walkers[msg.sender].status == Status.PENDING_WITHDRAW,\r\n            \"walker has wrong status\"\r\n        );\r\n        require(\r\n            block.timestamp - walkers[msg.sender].date > 14 days,\r\n            \"has not been long enough to withdraw\"\r\n        );\r\n        ERC20Interface(tellor).transfer(\r\n            msg.sender,\r\n            walkers[msg.sender].balance\r\n        );\r\n        walkers[msg.sender].balance = 0;\r\n        _banishWalker(msg.sender);\r\n        emit StakeWithdrawn(msg.sender);\r\n    }\r\n\r\n    //view functions\r\n\r\n    function checkReward() external view returns (uint256) {\r\n        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\r\n        if (timeSinceLastPayment > 6 * 30 days) {\r\n            timeSinceLastPayment = 6 * 30 days;\r\n        }\r\n        return ((rewardPool * timeSinceLastPayment) /\r\n            6 /\r\n            30 days /\r\n            fellowship.length);\r\n    }\r\n\r\n    function getFellowshipSize() external view returns (uint256) {\r\n        return fellowship.length;\r\n    }\r\n\r\n    function getWalkerDetails(address _walker)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            Status,\r\n            uint256,\r\n            uint256,\r\n            string memory\r\n        )\r\n    {\r\n        return (\r\n            walkers[_walker].date,\r\n            walkers[_walker].fellowshipIndex,\r\n            walkers[_walker].status,\r\n            walkers[_walker].balance,\r\n            walkers[_walker].rewardBalance,\r\n            walkers[_walker].name\r\n        );\r\n    }\r\n\r\n    function getWalkerInformation(address _walker, bytes32 _input)\r\n        external\r\n        view\r\n        returns (bytes memory _output)\r\n    {\r\n        return information[_walker][_input];\r\n    }\r\n\r\n    //checks whether they are a Walker\r\n    function isWalker(address _a) external view returns (bool _i) {\r\n        if (walkers[_a].status == Status.ACTIVE) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _banishWalker(address _oldWalker) internal {\r\n        fellowship[walkers[_oldWalker].fellowshipIndex] = fellowship[\r\n            fellowship.length - 1\r\n        ];\r\n        walkers[fellowship[fellowship.length - 1]].fellowshipIndex = walkers[\r\n            _oldWalker\r\n        ]\r\n            .fellowshipIndex;\r\n        fellowship.pop();\r\n        walkers[_oldWalker].fellowshipIndex = 0;\r\n        walkers[_oldWalker].status = Status.INACTIVE;\r\n        ERC20Interface(tellor).transfer(\r\n            _oldWalker,\r\n            walkers[_oldWalker].balance\r\n        );\r\n        walkers[_oldWalker].balance = 0;\r\n        rewardPool += walkers[_oldWalker].rewardBalance;\r\n        walkers[_oldWalker].rewardBalance = 0;\r\n    }\r\n\r\n    function _newWalker(address _walker, string memory _name) internal {\r\n        fellowship.push(_walker);\r\n        walkers[_walker] = Walker({\r\n            date: block.timestamp,\r\n            name: _name,\r\n            status: Status.UNFUNDED,\r\n            fellowshipIndex: fellowship.length - 1,\r\n            balance: 0,\r\n            rewardBalance: 0\r\n        });\r\n        emit NewWalker(_walker);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ERC20Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ERC20Interface {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address _addy) external returns (uint256);\r\n\r\n    function balanceOfAt(address _addy, uint256 _block)\r\n        external\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/Rivendale.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\nimport \"./Fellowship.sol\";\r\n\r\n/** \r\n @author Tellor Inc.\r\n @title Rivendale\r\n @dev This contract holds the voting logic to be used in the Fellowship contract\r\n**/\r\ncontract Rivendale {\r\n    //Storage\r\n    struct Vote {\r\n        uint256 walkerCount; //Number of total votes by walkers\r\n        uint256 payeeCount; //Number of total votes by payees\r\n        uint256 TRBCount; //Number of total votes by TRB holders\r\n        uint256 walkerTally; //Number of yes votes by walkers\r\n        uint256 payeeTally; //token weighted tally of yes votes by payees\r\n        uint256 TRBTally; //token weighted tally of yes votes by TRB holders\r\n        uint256 tally; //total weighted tally (/1000) of the vote\r\n        uint256 startDate; //startDate of the vote\r\n        uint256 startBlock; //startingblock of the vote\r\n        bool executed; //bool whether the vote has been settled and action ran\r\n        bytes32 ActionHash; //hash of the action to run upon successful vote\r\n    }\r\n\r\n    /*\r\n        Initial Weighting\r\n        40% - Walker Vote\r\n        40% - Customers\r\n        20% - TRB Holders\r\n    */\r\n    struct Weightings {\r\n        uint256 trbWeight; //weight of TRB holders\r\n        uint256 walkerWeight; //weight of Walkers\r\n        uint256 userWeight; //weight of payees (users)\r\n    }\r\n\r\n    Weightings weights;\r\n    mapping(address => mapping(uint256 => bool)) voted;\r\n    mapping(uint256 => Vote) voteBreakdown;\r\n    uint256 public voteCount;\r\n    address fellowship;\r\n\r\n    //Events\r\n    event NewVote(uint256 voteID, address destination, bytes data);\r\n    event Voted(uint256 tally, address user);\r\n    event VoteSettled(uint256 voteID, bool passed);\r\n\r\n    //Functions\r\n    /**\r\n     * @dev Constructor for setting initial variables\r\n     * @param _fellowship the address of the fellowshipContract\r\n     */\r\n    constructor(address _fellowship) {\r\n        fellowship = _fellowship;\r\n        setWeights(200, 400, 400); //should we have a way to change these?\r\n    }\r\n\r\n    function setWeights(\r\n        uint256 _trb,\r\n        uint256 _walker,\r\n        uint256 _user\r\n    ) internal {\r\n        weights.trbWeight = _trb;\r\n        weights.userWeight = _user;\r\n        weights.walkerWeight = _walker;\r\n    }\r\n\r\n    function getWeights()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (weights.trbWeight, weights.userWeight, weights.walkerWeight);\r\n    }\r\n\r\n    function openVote(address destination, bytes memory _function) external {\r\n        require(\r\n            ERC20Interface(Fellowship(fellowship).tellor()).transferFrom(\r\n                msg.sender,\r\n                fellowship,\r\n                1 ether\r\n            )\r\n        );\r\n        //increment vote count\r\n        voteCount += 1;\r\n        //set struct variables\r\n        voteBreakdown[voteCount].startBlock = block.number; //safe to index vote from voteBreakdown mapping with VoteCount?\r\n        voteBreakdown[voteCount].startDate = block.timestamp;\r\n        bytes32 actionHash =\r\n            keccak256(abi.encodePacked(destination, _function));\r\n        voteBreakdown[voteCount].ActionHash = actionHash;\r\n        emit NewVote(voteCount, destination, _function);\r\n    }\r\n\r\n    function settleVote(\r\n        uint256 _id,\r\n        address destination,\r\n        bytes calldata data\r\n    ) external returns (bool succ, bytes memory res) {\r\n        require(\r\n            block.timestamp - voteBreakdown[_id].startDate > 7 days,\r\n            \"vote has not been open long enough\"\r\n        );\r\n        require(\r\n            block.timestamp - voteBreakdown[_id].startDate < 14 days,\r\n            \"vote has failed / been too long\"\r\n        );\r\n        require(\r\n            voteBreakdown[_id].ActionHash ==\r\n                keccak256(abi.encodePacked(destination, data)),\r\n            \"Wrong action provided\"\r\n        );\r\n        require(!voteBreakdown[_id].executed, \"vote has already been settled\");\r\n        if (voteBreakdown[_id].tally > 500) {\r\n            (succ, res) = destination.call(data); //can we call this contract?\r\n        }\r\n        voteBreakdown[_id].executed = true;\r\n        emit VoteSettled(_id, voteBreakdown[_id].tally > 500);\r\n    }\r\n\r\n    function vote(uint256 _id, bool _supports) external {\r\n        require(!voted[msg.sender][_id], \"address has already voted\");\r\n        require(voteBreakdown[_id].startDate > 0, \"vote must be started\");\r\n        //Inherit Fellowship\r\n        Fellowship _fellowship = Fellowship(fellowship);\r\n        uint256[3] memory weightedVotes;\r\n        //If the sender is a supported Walker (voter)\r\n        if (_fellowship.isWalker(msg.sender)) {\r\n            //Increment this election's number of voters\r\n            voteBreakdown[_id].walkerCount++;\r\n            //If they vote yes, add to yes votes Tally\r\n            if (_supports) {\r\n                voteBreakdown[_id].walkerTally++;\r\n            }\r\n        }\r\n        if (voteBreakdown[_id].walkerCount > 0) {\r\n            weightedVotes[0] =\r\n                weights.walkerWeight *\r\n                (voteBreakdown[_id].walkerTally /\r\n                    voteBreakdown[_id].walkerCount);\r\n        }\r\n        //increment payee contribution total by voter's contribution\r\n        voteBreakdown[_id].payeeCount += _fellowship.payments(msg.sender);\r\n        //should we make this just \"balanceOf\" to make it ERC20 compliant\r\n        uint256 _bal =\r\n            ERC20Interface(_fellowship.tellor()).balanceOfAt(\r\n                msg.sender,\r\n                voteBreakdown[_id].startBlock\r\n            );\r\n        voteBreakdown[_id].TRBCount += _bal;\r\n        if (_supports) {\r\n            voteBreakdown[_id].payeeTally += _fellowship.payments(msg.sender);\r\n            voteBreakdown[_id].TRBTally += _bal;\r\n        }\r\n        if (voteBreakdown[_id].payeeCount > 0) {\r\n            weightedVotes[1] =\r\n                weights.userWeight *\r\n                (voteBreakdown[_id].payeeTally / voteBreakdown[_id].payeeCount);\r\n        }\r\n        if (voteBreakdown[_id].TRBCount > 0) {\r\n            weightedVotes[2] =\r\n                weights.trbWeight *\r\n                (voteBreakdown[_id].TRBTally / voteBreakdown[_id].TRBCount);\r\n        }\r\n        voteBreakdown[_id].tally =\r\n            weightedVotes[0] +\r\n            weightedVotes[1] +\r\n            weightedVotes[2];\r\n        voted[msg.sender][_id] = true;\r\n        emit Voted(voteBreakdown[_id].tally, msg.sender);\r\n    }\r\n\r\n    function getVoteInfo(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[9] memory,\r\n            bool,\r\n            bytes32\r\n        )\r\n    {\r\n        return (\r\n            [\r\n                voteBreakdown[_id].walkerCount,\r\n                voteBreakdown[_id].payeeCount,\r\n                voteBreakdown[_id].TRBCount,\r\n                voteBreakdown[_id].walkerTally,\r\n                voteBreakdown[_id].payeeTally,\r\n                voteBreakdown[_id].TRBTally,\r\n                voteBreakdown[_id].tally,\r\n                voteBreakdown[_id].startDate,\r\n                voteBreakdown[_id].startBlock\r\n            ],\r\n            voteBreakdown[_id].executed,\r\n            voteBreakdown[_id].ActionHash\r\n        );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}