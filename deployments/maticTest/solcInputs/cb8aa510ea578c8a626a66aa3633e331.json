{
  "language": "Solidity",
  "sources": {
    "contracts/Fellowship.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.2;\r\n\r\nimport \"./interfaces/ERC20Interface.sol\";\r\n\r\n/****\r\n\r\n████████╗██╗░░██╗███████╗  ███████╗███████╗██╗░░░░░██╗░░░░░░█████╗░░██╗░░░░░░░██╗░██████╗██╗░░██╗██╗██████╗░\r\n╚══██╔══╝██║░░██║██╔════╝  ██╔════╝██╔════╝██║░░░░░██║░░░░░██╔══██╗░██║░░██╗░░██║██╔════╝██║░░██║██║██╔══██╗\r\n░░░██║░░░███████║█████╗░░  █████╗░░█████╗░░██║░░░░░██║░░░░░██║░░██║░╚██╗████╗██╔╝╚█████╗░███████║██║██████╔╝\r\n░░░██║░░░██╔══██║██╔══╝░░  ██╔══╝░░██╔══╝░░██║░░░░░██║░░░░░██║░░██║░░████╔═████║░░╚═══██╗██╔══██║██║██╔═══╝░\r\n░░░██║░░░██║░░██║███████╗  ██║░░░░░███████╗███████╗███████╗╚█████╔╝░░╚██╔╝░╚██╔╝░██████╔╝██║░░██║██║██║░░░░░\r\n░░░╚═╝░░░╚═╝░░╚═╝╚══════╝  ╚═╝░░░░░╚══════╝╚══════╝╚══════╝░╚════╝░░░░╚═╝░░░╚═╝░░╚═════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░\r\n\r\n*****/\r\n\r\n/** \r\n @author Tellor Inc.\r\n @title Fellowship\r\n @dev This contract holds the selected few chosen as part of the Fellowship\r\n**/\r\ncontract Fellowship {\r\n    //Storage\r\n    enum Status {ACTIVE, INACTIVE, PENDING_WITHDRAW, UNFUNDED}\r\n\r\n    struct Walker {\r\n        Status status; //status of walker\r\n        uint256 date; //date the walker initally was chosen\r\n        uint256 fellowshipIndex; //index of walker in the fellowship array\r\n        uint256 balance; //TRB balance of walker (must be > stakeAmount to be ACTIVE)\r\n        uint256 rewardBalance; //balance of rewards they own\r\n        string name; //name of walker\r\n    }\r\n\r\n    uint256 public lastPayDate; //most recent date walkers were paid\r\n    uint256 public rewardPool; //sum of all payments for services in contract\r\n    uint256 public stakeAmount; //minimum amount each walker needs to stake\r\n    address public rivendell; //the address of the voting contract\r\n    address public tellor; //address of tellor (the token for staking and payments)\r\n\r\n    mapping(address => mapping(bytes32 => bytes)) information; //allows parties to store arbitrary information\r\n    mapping(address => Walker) public walkers; //a mapping of an address to their information as a Walker\r\n    mapping(address => uint256) public payments; //a mapping of an address to the payment amount they've given\r\n    //The Fellowship:\r\n    address[] public fellowship; //The array of chosen individuals who are part of the fellowship\r\n\r\n    //Events\r\n    event NewWalker1(address walker);\r\n    event NewWalker(address walker);\r\n    event NewWalkerInformation(address walker, bytes32 input, bytes output);\r\n    event WalkerBanished(address walker);\r\n    event StakeWithdrawalRequestStarted(address walker);\r\n    event StakeWithdrawn(address walker);\r\n    event PaymentDeposited(address payee, uint256 amount);\r\n    event RewardsPaid(uint256 rewardPerWalker);\r\n\r\n    //Modifiers\r\n    /**\r\n     * @dev This modifier restricts the function to only the Rivendell contract\r\n     */\r\n    modifier onlyRivendell {\r\n        require(\r\n            msg.sender == rivendell,\r\n            \"Only rivendell can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    //Functions\r\n    /**\r\n     * @dev Constructor for setting initial variables\r\n     * @param _tellor the address of the tellor contract\r\n     * @param _initialWalkers an array of three addresses to serve as the initial walkers\r\n     */\r\n    constructor(address _tellor, address[3] memory _initialWalkers) {\r\n        tellor = _tellor;\r\n        _newWalker(_initialWalkers[0], \"Aragorn\");\r\n        _newWalker(_initialWalkers[1], \"Legolas\");\r\n        _newWalker(_initialWalkers[2], \"Gimli\");\r\n        stakeAmount = 10 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to banish a walker\r\n     * @param _oldWalker address of walker to be banished (removed from Fellowship)\r\n     **/\r\n    function banishWalker(address _oldWalker) external onlyRivendell {\r\n        _banishWalker(_oldWalker);\r\n        emit WalkerBanished(_oldWalker);\r\n    }\r\n\r\n    function depositPayment(uint256 _amount) external {\r\n        payReward();\r\n\r\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\r\n        payments[msg.sender] += _amount;\r\n        rewardPool += _amount;\r\n        emit PaymentDeposited(msg.sender, _amount);\r\n    }\r\n\r\n    function depositStake(uint256 _amount) external {\r\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\r\n        walkers[msg.sender].balance += _amount;\r\n        require(\r\n            walkers[msg.sender].status != Status.INACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        require(\r\n            walkers[msg.sender].status != Status.PENDING_WITHDRAW,\r\n            \"Walker has wrong status\"\r\n        );\r\n        if (walkers[msg.sender].balance >= stakeAmount) {\r\n            walkers[msg.sender].status = Status.ACTIVE;\r\n        }\r\n    }\r\n\r\n    function newRivendell(address _newRivendell) external {\r\n        require(\r\n            msg.sender == rivendell || rivendell == address(0),\r\n            \"Only rivendell can call this function.\"\r\n        );\r\n        rivendell = _newRivendell;\r\n    }\r\n\r\n    function newWalker(address _walker, string memory _name)\r\n        external\r\n        onlyRivendell\r\n    {\r\n        require(walkers[_walker].date == 0, \"cannot already be a walker\");\r\n        _newWalker(_walker, _name);\r\n    }\r\n\r\n    function payReward() public {\r\n        lastPayDate = block.timestamp;\r\n\r\n        if (rewardPool > 0) {\r\n            uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\r\n            if (timeSinceLastPayment > 6 * 30 days) {\r\n                timeSinceLastPayment = 6 * 30 days;\r\n            }\r\n            uint256 reward =\r\n                (rewardPool * timeSinceLastPayment) /\r\n                    6 /\r\n                    30 days /\r\n                    fellowship.length;\r\n            for (uint256 i = 0; i < fellowship.length; i++) {\r\n                if (walkers[fellowship[i]].status == Status.ACTIVE) {\r\n                    walkers[fellowship[i]].rewardBalance += reward;\r\n                    rewardPool -= reward;\r\n                }\r\n            }\r\n            emit RewardsPaid(reward);\r\n        }\r\n    }\r\n\r\n    //to pay out the reward\r\n    function recieveReward() external {\r\n        require(\r\n            walkers[msg.sender].status == Status.ACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        ERC20Interface(tellor).transfer(\r\n            msg.sender,\r\n            walkers[msg.sender].rewardBalance\r\n        );\r\n        walkers[msg.sender].rewardBalance = 0;\r\n    }\r\n\r\n    function requestStakingWithdraw() external {\r\n        require(\r\n            walkers[msg.sender].status != Status.INACTIVE,\r\n            \"Walker has wrong status\"\r\n        );\r\n        walkers[msg.sender].status = Status.PENDING_WITHDRAW;\r\n        walkers[msg.sender].date = block.timestamp;\r\n        emit StakeWithdrawalRequestStarted(msg.sender);\r\n    }\r\n\r\n    function setStakeAmount(uint256 _amount) external onlyRivendell {\r\n        stakeAmount = _amount;\r\n        for (uint256 i = 0; i < fellowship.length; i++) {\r\n            if (walkers[fellowship[i]].balance < stakeAmount) {\r\n                walkers[fellowship[i]].status = Status.UNFUNDED;\r\n            }\r\n        }\r\n    }\r\n\r\n    //a function to store input about keys on other chains or other necessary details;\r\n    function setWalkerInformation(bytes32 _input, bytes memory _output)\r\n        external\r\n    {\r\n        information[msg.sender][_input] = _output;\r\n        emit NewWalkerInformation(msg.sender, _input, _output);\r\n    }\r\n\r\n    function slashWalker(\r\n        address _walker,\r\n        uint256 _amount,\r\n        bool _banish\r\n    ) external onlyRivendell {\r\n        walkers[_walker].balance -= _amount;\r\n        rewardPool += _amount;\r\n        if (_banish) {\r\n            _banishWalker(_walker);\r\n        } else if (walkers[_walker].balance < stakeAmount) {\r\n            walkers[_walker].status = Status.UNFUNDED;\r\n        }\r\n    }\r\n\r\n    function withdrawStake() external {\r\n        require(\r\n            walkers[msg.sender].status == Status.PENDING_WITHDRAW,\r\n            \"walker has wrong status\"\r\n        );\r\n        require(\r\n            block.timestamp - walkers[msg.sender].date > 14 days,\r\n            \"has not been long enough to withdraw\"\r\n        );\r\n        ERC20Interface(tellor).transfer(\r\n            msg.sender,\r\n            walkers[msg.sender].balance\r\n        );\r\n        walkers[msg.sender].balance = 0;\r\n        _banishWalker(msg.sender);\r\n        emit StakeWithdrawn(msg.sender);\r\n    }\r\n\r\n    //view functions\r\n\r\n    function checkReward() external view returns (uint256) {\r\n        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\r\n        if (timeSinceLastPayment > 6 * 30 days) {\r\n            timeSinceLastPayment = 6 * 30 days;\r\n        }\r\n        return ((rewardPool * timeSinceLastPayment) /\r\n            6 /\r\n            30 days /\r\n            fellowship.length);\r\n    }\r\n\r\n    function getFellowshipSize() external view returns (uint256) {\r\n        return fellowship.length;\r\n    }\r\n\r\n    function getWalkerDetails(address _walker)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            Status,\r\n            uint256,\r\n            uint256,\r\n            string memory\r\n        )\r\n    {\r\n        return (\r\n            walkers[_walker].date,\r\n            walkers[_walker].fellowshipIndex,\r\n            walkers[_walker].status,\r\n            walkers[_walker].balance,\r\n            walkers[_walker].rewardBalance,\r\n            walkers[_walker].name\r\n        );\r\n    }\r\n\r\n    function getWalkerInformation(address _walker, bytes32 _input)\r\n        external\r\n        view\r\n        returns (bytes memory _output)\r\n    {\r\n        return information[_walker][_input];\r\n    }\r\n\r\n    //checks whether they are a Walker\r\n    function isWalker(address _a) external view returns (bool _i) {\r\n        if (walkers[_a].status == Status.ACTIVE) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _banishWalker(address _oldWalker) internal {\r\n        fellowship[walkers[_oldWalker].fellowshipIndex] = fellowship[\r\n            fellowship.length - 1\r\n        ];\r\n        walkers[fellowship[fellowship.length - 1]].fellowshipIndex = walkers[\r\n            _oldWalker\r\n        ]\r\n            .fellowshipIndex;\r\n        fellowship.pop();\r\n        walkers[_oldWalker].fellowshipIndex = 0;\r\n        walkers[_oldWalker].status = Status.INACTIVE;\r\n        ERC20Interface(tellor).transfer(\r\n            _oldWalker,\r\n            walkers[_oldWalker].balance\r\n        );\r\n        walkers[_oldWalker].balance = 0;\r\n        rewardPool += walkers[_oldWalker].rewardBalance;\r\n        walkers[_oldWalker].rewardBalance = 0;\r\n    }\r\n\r\n    function _newWalker(address _walker, string memory _name) internal {\r\n        fellowship.push(_walker);\r\n        walkers[_walker] = Walker({\r\n            date: block.timestamp,\r\n            name: _name,\r\n            status: Status.UNFUNDED,\r\n            fellowshipIndex: fellowship.length - 1,\r\n            balance: 0,\r\n            rewardBalance: 0\r\n        });\r\n        emit NewWalker(_walker);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ERC20Interface.sol": {
      "content": "\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ERC20Interface{\r\n    function transfer(address _to, uint _amount) external returns(bool);\r\n    function transferFrom(address _from,address _to, uint _amount) external returns(bool);\r\n    function balanceOf(address _addy) external returns(uint256);\r\n    function balanceOfAt(address _addy, uint _block) external returns(uint256);\r\n}"
    },
    "contracts/Rivendell.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.2;\r\n\r\nimport \"./Fellowship.sol\";\r\n\r\n/** \r\n @author Tellor Inc.\r\n @title Rivendell\r\n @dev This contract holds the voting logic to be used in the Fellowship contract\r\n**/\r\ncontract Rivendell {\r\n    //Storage\r\n    struct Vote {\r\n        uint256 walkerCount; //Number of total votes by walkers\r\n        uint256 payeeCount; //Number of total votes by payees\r\n        uint256 TRBCount; //Number of total votes by TRB holders\r\n        uint256 walkerTally; //Number of yes votes by walkers\r\n        uint256 payeeTally; //token weighted tally of yes votes by payees\r\n        uint256 TRBTally; //token weighted tally of yes votes by TRB holders\r\n        uint256 tally; //total weighted tally (/1000) of the vote\r\n        uint256 startDate; //startDate of the vote\r\n        uint256 startBlock; //startingblock of the vote\r\n        bool executed; //bool whether the vote has been settled and action ran\r\n        bytes32 ActionHash; //hash of the action to run upon successful vote\r\n    }\r\n\r\n    /*\r\n        Initial Weighting\r\n        40% - Walker Vote\r\n        40% - Customers\r\n        20% - TRB Holders\r\n    */\r\n    struct Weightings {\r\n        uint256 trbWeight; //weight of TRB holders\r\n        uint256 walkerWeight; //weight of Walkers\r\n        uint256 userWeight; //weight of payees (users)\r\n    }\r\n\r\n    Weightings weights;\r\n    mapping(address => mapping(uint256 => bool)) voted;\r\n    mapping(uint256 => Vote) voteBreakdown;\r\n    uint256 public voteCount;\r\n    address fellowship;\r\n\r\n    //Events\r\n    event NewVote(uint256 voteID, address destination, bytes data);\r\n    event Voted(uint256 tally, address user);\r\n    event VoteSettled(uint256 voteID, bool passed);\r\n\r\n    //Functions\r\n    /**\r\n     * @dev Constructor for setting initial variables\r\n     * @param _fellowship the address of the fellowshipContract\r\n     */\r\n    constructor(address _fellowship) {\r\n        fellowship = _fellowship;\r\n        setWeights(200, 400, 400); //should we have a way to change these?\r\n    }\r\n\r\n    function setWeights(\r\n        uint256 _trb,\r\n        uint256 _walker,\r\n        uint256 _user\r\n    ) internal {\r\n        weights.trbWeight = _trb;\r\n        weights.userWeight = _user;\r\n        weights.walkerWeight = _walker;\r\n    }\r\n\r\n    function getWeights()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (weights.trbWeight, weights.userWeight, weights.walkerWeight);\r\n    }\r\n\r\n    function openVote(address destination, bytes memory _function) external {\r\n        require(\r\n            ERC20Interface(Fellowship(fellowship).tellor()).transferFrom(\r\n                msg.sender,\r\n                fellowship,\r\n                1 ether\r\n            )\r\n        );\r\n        //increment vote count\r\n        voteCount += 1;\r\n        //set struct variables\r\n        voteBreakdown[voteCount].startBlock = block.number; //safe to index vote from voteBreakdown mapping with VoteCount?\r\n        voteBreakdown[voteCount].startDate = block.timestamp;\r\n        bytes32 actionHash =\r\n            keccak256(abi.encodePacked(destination, _function));\r\n        voteBreakdown[voteCount].ActionHash = actionHash;\r\n        emit NewVote(voteCount, destination, _function);\r\n    }\r\n\r\n    function settleVote(\r\n        uint256 _id,\r\n        address destination,\r\n        bytes calldata data\r\n    ) external returns (bool succ, bytes memory res) {\r\n        require(\r\n            block.timestamp - voteBreakdown[_id].startDate > 7 days,\r\n            \"vote has not been open long enough\"\r\n        );\r\n        require(\r\n            block.timestamp - voteBreakdown[_id].startDate < 14 days,\r\n            \"vote has failed / been too long\"\r\n        );\r\n        require(\r\n            voteBreakdown[_id].ActionHash ==\r\n                keccak256(abi.encodePacked(destination, data)),\r\n            \"Wrong action provided\"\r\n        );\r\n        require(!voteBreakdown[_id].executed, \"vote has already been settled\");\r\n        if (voteBreakdown[_id].tally > 500) {\r\n            (succ, res) = destination.call(data); //can we call this contract?\r\n        }\r\n        voteBreakdown[_id].executed = true;\r\n        emit VoteSettled(_id, voteBreakdown[_id].tally > 500);\r\n    }\r\n\r\n    function vote(uint256 _id, bool _supports) external {\r\n        require(!voted[msg.sender][_id], \"address has already voted\");\r\n        require(voteBreakdown[_id].startDate > 0, \"vote must be started\");\r\n        //Inherit Fellowship\r\n        Fellowship _fellowship = Fellowship(fellowship);\r\n        uint256[3] memory weightedVotes;\r\n        //If the sender is a supported Walker (voter)\r\n        if (_fellowship.isWalker(msg.sender)) {\r\n            //Increment this election's number of voters\r\n            voteBreakdown[_id].walkerCount++;\r\n            //If they vote yes, add to yes votes Tally\r\n            if (_supports) {\r\n                voteBreakdown[_id].walkerTally++;\r\n            }\r\n        }\r\n        if (voteBreakdown[_id].walkerCount > 0) {\r\n            weightedVotes[0] =\r\n                weights.walkerWeight *\r\n                (voteBreakdown[_id].walkerTally /\r\n                    voteBreakdown[_id].walkerCount);\r\n        }\r\n        //increment payee contribution total by voter's contribution\r\n        voteBreakdown[_id].payeeCount += _fellowship.payments(msg.sender);\r\n        //should we make this just \"balanceOf\" to make it ERC20 compliant\r\n        uint256 _bal =\r\n            ERC20Interface(_fellowship.tellor()).balanceOfAt(\r\n                msg.sender,\r\n                voteBreakdown[_id].startBlock\r\n            );\r\n        voteBreakdown[_id].TRBCount += _bal;\r\n        if (_supports) {\r\n            voteBreakdown[_id].payeeTally += _fellowship.payments(msg.sender);\r\n            voteBreakdown[_id].TRBTally += _bal;\r\n        }\r\n        if (voteBreakdown[_id].payeeCount > 0) {\r\n            weightedVotes[1] =\r\n                weights.userWeight *\r\n                (voteBreakdown[_id].payeeTally / voteBreakdown[_id].payeeCount);\r\n        }\r\n        if (voteBreakdown[_id].TRBCount > 0) {\r\n            weightedVotes[2] =\r\n                weights.trbWeight *\r\n                (voteBreakdown[_id].TRBTally / voteBreakdown[_id].TRBCount);\r\n        }\r\n        voteBreakdown[_id].tally =\r\n            weightedVotes[0] +\r\n            weightedVotes[1] +\r\n            weightedVotes[2];\r\n        voted[msg.sender][_id] = true;\r\n        emit Voted(voteBreakdown[_id].tally, msg.sender);\r\n    }\r\n\r\n    function getVoteInfo(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[9] memory,\r\n            bool,\r\n            bytes32\r\n        )\r\n    {\r\n        return (\r\n            [\r\n                voteBreakdown[_id].walkerCount,\r\n                voteBreakdown[_id].payeeCount,\r\n                voteBreakdown[_id].TRBCount,\r\n                voteBreakdown[_id].walkerTally,\r\n                voteBreakdown[_id].payeeTally,\r\n                voteBreakdown[_id].TRBTally,\r\n                voteBreakdown[_id].tally,\r\n                voteBreakdown[_id].startDate,\r\n                voteBreakdown[_id].startBlock\r\n            ],\r\n            voteBreakdown[_id].executed,\r\n            voteBreakdown[_id].ActionHash\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/testContracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory tokenName, string memory tokenSymbol) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n      /**\r\n     * @dev Public function to mint tokens for the passed address\r\n     * @param user The address which will own the tokens\r\n     *\r\n     */\r\n    function faucet(address user) external {\r\n        _mint(user, 1000 ether);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total supply of the token.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of a given user.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of a given user.\r\n     */\r\n    function balanceOfAt(address account, uint256 _block) public view returns (uint256) {\r\n        return _balances[account] + _block * 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from user to another\r\n     * @param recipient The destination address\r\n     * @param amount The amount of tokens, including decimals, to transfer\r\n     * @return bool If the transfer succeeded\r\n     *\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Retruns the amount that an address is alowed to spend of behalf of other\r\n     * @param owner The address which owns the tokens\r\n     * @param spender The address that will use the tokens\r\n     * @return uint256 Indicating the amount of allowed tokens\r\n     *\r\n     */\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Approves  amount that an address is alowed to spend of behalf of other\r\n     * @param spender The address which user the tokens\r\n     * @param amount The amount that msg.sender is allowing spender to use\r\n     * @return bool If the transaction succeeded\r\n     *\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n     /**\r\n     * @dev Transfer tokens from user to another\r\n     * @param sender The address which owns the tokens\r\n     * @param recipient The destination address\r\n     * @param amount The amount of tokens, including decimals, to transfer\r\n     * @return bool If the transfer succeeded\r\n     *\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to perform token transfer\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to create new tokens for the user\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn tokens for the user\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to approve tokens for the user\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}